<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mate Soos | MeelGroup</title>
    <link>https://meelgroup.github.io/author/mate-soos/</link>
      <atom:link href="https://meelgroup.github.io/author/mate-soos/index.xml" rel="self" type="application/rss+xml" />
    <description>Mate Soos</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>© 2019</copyright><lastBuildDate>Mon, 09 May 2022 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://meelgroup.github.io/images/icon_hu1dd832c4da814f17fe02e3737f0ae144_14882_512x512_fill_lanczos_center_2.png</url>
      <title>Mate Soos</title>
      <link>https://meelgroup.github.io/author/mate-soos/</link>
    </image>
    
    <item>
      <title>On Quantitative Testing of Samplers</title>
      <link>https://meelgroup.github.io/publication/cp22/</link>
      <pubDate>Mon, 09 May 2022 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/cp22/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Gaussian Elimination Meets Maximum Satisfiability</title>
      <link>https://meelgroup.github.io/publication/kr21/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/kr21/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Designing Samplers is Easy: The Boon of Testers</title>
      <link>https://meelgroup.github.io/publication/fmcad21/</link>
      <pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/fmcad21/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Leveraging GPUs for Effective Clause Sharing in Parallel SAT Solving</title>
      <link>https://meelgroup.github.io/publication/sat21_gpu/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/sat21_gpu/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Tinted, Detached, and Lazy CNF-XOR solving and its Applications to Counting and Sampling</title>
      <link>https://meelgroup.github.io/publication/cav20sgm/</link>
      <pubDate>Mon, 18 May 2020 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/cav20sgm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CrystalBall: SAT solving, Data Gathering, and Machine Learning</title>
      <link>https://meelgroup.github.io/post/crystallball/</link>
      <pubDate>Sun, 03 Nov 2019 00:00:00 +0700</pubDate>
      <guid>https://meelgroup.github.io/post/crystallball/</guid>
      <description>&lt;p&gt; &lt;/i&gt;Link to the  &lt;a href=&#34;https://www.msoos.org/2019/06/crystalball-sat-solving-data-gathering-and-machine-learning/&#34;&gt;original post&lt;/a&gt; on CrystallBall.&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GANAK: A Scalable Probabilistic Exact Model Counter</title>
      <link>https://meelgroup.github.io/publication/ijcai19_ganak/</link>
      <pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/ijcai19_ganak/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CrystalBall: Gazing in the Black Box of SAT Solving </title>
      <link>https://meelgroup.github.io/publication/sat19_cball/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/sat19_cball/</guid>
      <description></description>
    </item>
    
    <item>
      <title>BOSPHORUS: Bridging ANF and CNF Solvers </title>
      <link>https://meelgroup.github.io/publication/date_cscm19/</link>
      <pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/date_cscm19/</guid>
      <description>&lt;p&gt;Algebraic Normal Form (ANF) and Conjunctive Normal Form (CNF) are commonly used to encode problems in Boolean algebra. ANFs are typically solved via Gröbner basis algorithms, often using more memory than is feasible; while CNFs are solved using SAT solvers, which cannot exploit the algebra of polynomials naturally. We propose a paradigm that bridges between ANF and CNF solving techniques: the techniques are applied in an iterative manner to learn facts to augment the original problems. Experiments on over 1,100 benchmarks arising from four different applications domains demonstrate that learnt facts can significantly improve runtime and enable more benchmarks to be solved.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bosphorus: An ANF and CNF simplifier and converter</title>
      <link>https://meelgroup.github.io/post/bosphorus/</link>
      <pubDate>Sat, 05 Jan 2019 11:06:17 +0530</pubDate>
      <guid>https://meelgroup.github.io/post/bosphorus/</guid>
      <description>&lt;p&gt;We are happy to release our ANF and CNF simplifier and converter called &lt;a href=&#34;https://github.com/meelgroup/bosphorus&#34;&gt;Bosphorus&lt;/a&gt;. It has helped us break multiple real-world ciphers. It has been re-released with major work by Davin Choo &amp;amp; Kian Ming A. Chai from &lt;a href=&#34;https://www.dso.org.sg/&#34;&gt;DSO National Laboratories&lt;/a&gt; Singapore and Mate Soos &amp;amp; Kuldeep Meel from NUS. The &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/date-cscm19.pdf&#34;&gt;paper&lt;/a&gt; will be published at the &lt;a href=&#34;https://www.date-conference.com/&#34;&gt;DATE 2019&lt;/a&gt; conference.&lt;/p&gt;
&lt;h3&gt;ANFs and CNFs&lt;/h3&gt;
&lt;p&gt;Algebraic Normal Form is a form that is used by most cryptographers to describe symmetric ciphers, hash algorithms, and lately a lot of &lt;a href=&#34;https://csrc.nist.gov/projects/post-quantum-cryptography&#34;&gt;post-quantum asymmetric ciphers&lt;/a&gt;. It’s a very simple notation that basically looks like this:&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;x1 ⊕ x2 ⊕ x3 = 0&lt;br&gt;x1 * x2 ⊕ x2 * x3 + 1 = 0&lt;/pre&gt;
&lt;p&gt;Where “⊕” represents XOR and “&lt;em&gt;” represents the AND operator. So the first line here is an XOR of binary variables x1, x2 and x3 and their XOR must be equal to 0. The second line means that “(x1 AND x2)  XOR (x2 AND x3)” must be equal to 1. This normal form allows to see a bunch of interesting things. For example, it allows us to see the so-called “maximum degree” of the set of equations, where the degree is the maximum number of variables AND-ed together in one line. The above set of equations has a maximum degree of 2, as (x1&lt;/em&gt;x2) is of degree 2. Degrees can often be a good indicator for the complexity of a problem.&lt;/p&gt;
&lt;p&gt;What’s good about ANFs is that there are a number of well-known algorithms to break problems described in them. For example, one can do &lt;a href=&#34;https://link.springer.com/content/pdf/10.1007%2F3-540-48405-1_2.pdf&#34;&gt;(re)linearization&lt;/a&gt; and Gauss-Jordan elimination, or one could run Grobner-basis algorithms such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Faug%C3%A8re%27s_F4_and_F5_algorithms&#34;&gt;F4/F5&lt;/a&gt; on it. Sometimes, the ANFs can also be solved by converting them to another normal form, Conjunctive Normal Form (CNF), used by SAT solvers. The CNF normal form looks like:&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;x1 V x2 V x3&lt;br&gt;-x1 V x3&lt;/pre&gt;
&lt;p&gt;Where x1, x2 and x3 are binary variables, “V” is the logical OR, and each line must be equal to TRUE. Using CNF is interesting, because the solvers used to solve them, &lt;a href=&#34;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem&#34;&gt;SAT solvers&lt;/a&gt;, typically provide a different set of trade-offs for solving than ANF problem solvers. SAT solvers tend to use more CPU time but a lot less memory, sometimes making problems viable to solve in the “real world”. Whereas sometimes breaking of a cipher is enough to be demonstrated on paper, it also happens that one wants to break a cipher in the &lt;a href=&#34;https://twitter.com/David3141593/status/1080606827384131590&#34;&gt;real world&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Bridging and Simplifying&lt;/h3&gt;
&lt;p&gt;We believe that Bosphorus is a first of its kind system that allows ANFs to be simplified using both CNF- and ANF-based systems. It can also convert between the two normal forms and can act both as an ANF and a CNF preprocessor, like &lt;a href=&#34;http://fmv.jku.at/papers/EenBiere-SAT05.pdf&#34;&gt;SatELite&lt;/a&gt; (by Een and Biere) was for CNF. We believe this makes Bosphorus unique and also uniquely useful, especially while working on ANFs.&lt;/p&gt;
&lt;p&gt;Bosphorus uses an iterative architecture that performs the following set of steps, either until it runs out of time or until fixed point:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Replace variables and propagate constants in the ANF &lt;/li&gt;&lt;li&gt;Run limited &lt;a href=&#34;https://en.wikipedia.org/wiki/XSL_attack&#34;&gt;Extended Linarization (XL)&lt;/a&gt;  and inject back unit and binary XORs&lt;/li&gt;&lt;li&gt;Run limited &lt;a href=&#34;https://rd.springer.com/content/pdf/10.1007%2F978-3-642-34047-5_18.pdf&#34;&gt;ElimLin&lt;/a&gt;  and inject back unit and binary XORs&lt;/li&gt;&lt;li&gt;Convert to CNF, run a SAT solver for a limited number of conflicts and inject back unit and binary (and potentially longer) XORs&lt;/li&gt;&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;Bosphorus.png&#34; alt=&#34;alt_text&#34;&gt;&lt;/p&gt;
&lt;p&gt;In other words, the system is an iterative simplifier/preprocessor that invokes multiple reasoning systems to try to simplify the problem as much as possible. It can outright solve the system, as most of these reasoning systems are complete, but the point is to run them only to a certain limit and inject back into the ANF the easily “digestible” information. The simplified ANF can then either be output as an ANF or a CNF.&lt;/p&gt;
&lt;p&gt;Bosphorus can also take a CNF as input, perform the trivial transformation of it to ANF and then treat it as an ANF. This allows the CNF to be simplified using techniques previously unavailable to CNF systems, such as XL.&lt;/p&gt;
&lt;h3&gt;ANF to CNF Conversion&lt;/h3&gt;
&lt;p&gt;ANF-to-CNF conversion is not considered that hard, and that’s why there hasn’t been too much academic effort devoted to it. However, it’s an important step without which a lot of opportunities would be missed.&lt;/p&gt;
&lt;p&gt;The implemented system contains a pretty advanced ANF-to-CNF converter, using Karnaugh tables through &lt;a href=&#34;https://en.wikipedia.org/wiki/Espresso_heuristic_logic_minimizer&#34;&gt;Espresso&lt;/a&gt;, XOR cutting, monomial reuse, etc. It should give a pretty optimal CNF for all ANFs. So Bosphorus can be used also just as an ANF-to-CNF converter, though it’s so much more.&lt;/p&gt;
&lt;h3&gt;Final Thoughts&lt;/h3&gt;
&lt;p&gt;One of the biggest capabilities of &lt;a href=&#34;https://github.com/meelgroup/bosphorus&#34;&gt;Bosphorus&lt;/a&gt; is that it can simplify/preprocess ANF systems so more heavyweight ANF solvers can have a go at them. Its ANF simplification is so powerful, it can even help to solve some CNFs by lifting them to ANF, running the ANF simplifiers, converting it back to CNF, and solving that(!). We believe our initial results, published in the &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/date-cscm19.pdf&#34;&gt;paper&lt;/a&gt;, are very encouraging. Further, the system is in a ready-to-use state: there is a &lt;a href=&#34;https://cloud.docker.com/repository/docker/msoos/bosphorus&#34;&gt;Docker image&lt;/a&gt;, the source should build without a hitch, and there is even a precompiled Linux &lt;a href=&#34;https://github.com/meelgroup/bosphorus/releases/&#34;&gt;binary&lt;/a&gt;. We would love to hear about your experience using it.&lt;/p&gt;
&lt;p&gt;&lt;i&gt;Thanks to Karsten Nohl from &lt;a href=&#34;https://srlabs.de/&#34;&gt;Security Research Labs.&lt;/a&gt;&lt;/i&gt; This post has been adapted from &lt;a href=&#34;https://www.msoos.org/2019/01/bosphorus-an-anf-and-cnf-simplifier-and-converter/&#34;&gt;Mate&amp;rsquo;s post&lt;/a&gt; on Bosphorus.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>BIRD: Engineering an Efficient CNF-XOR SAT Solver and its Applications to Approximate Model Counting</title>
      <link>https://meelgroup.github.io/publication/aaai19_bird/</link>
      <pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://meelgroup.github.io/publication/aaai19_bird/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ApproxMCv3: A modern approximate model counter</title>
      <link>https://meelgroup.github.io/post/approxmcv3/</link>
      <pubDate>Sun, 25 Nov 2018 11:06:17 +0530</pubDate>
      <guid>https://meelgroup.github.io/post/approxmcv3/</guid>
      <description>&lt;p&gt;ApproxMC is a scalable, approximate model counter that provides PAC (probably approximately correct) guarantees. We have been working very hard on speeding up approximate model counting for SAT and have made real progress. The research paper, accepted at AAAI-19 is available &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/aaai19-sm.pdf&#34;&gt;here&lt;/a&gt;. The code is available &lt;a href=&#34;https://github.com/meelgroup/ApproxMC&#34;&gt;here&lt;/a&gt; (release with static binary &lt;a href=&#34;https://github.com/meelgroup/ApproxMC/releases&#34;&gt;here&lt;/a&gt;). The main result is that we can solve a &lt;strong&gt;lot&lt;/strong&gt; more problems than before. The speed of solving is orders(!) of magnitude faster than the previous best system:&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;size-full wp-image-3214 aligncenter&#34; src=&#34;http://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611.png&#34; alt=&#34;&#34; width=&#34;1202&#34; height=&#34;740&#34; srcset=&#34;https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611.png 1202w, https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611-300x185.png 300w, https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611-768x473.png 768w, https://www.msoos.org/wordpress/wp-content/uploads/2018/11/Screenshot_20181125_202611-1024x630.png 1024w&#34; sizes=&#34;(max-width: 1202px) 100vw, 1202px&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Background&lt;/h3&gt;
&lt;p&gt;The idea of approximate model counting, originally &lt;a href=&#34;https://arxiv.org/pdf/1306.5726&#34;&gt;by Chakraborty, Meel and Vardi&lt;/a&gt; was a huge hit back in 2013, and many papers have followed it, trying to improve its results. All of them were basically tied to &lt;a href=&#34;https://github.com/msoos/cryptominisat&#34;&gt;CryptoMiniSat&lt;/a&gt;, the SAT solver that is maintained by Mate, as all of them relied on XOR constraints being added to the regular CNF of a typical SAT problem.&lt;/p&gt;
&lt;p&gt;So it made sense to examine what CryptoMiniSat could do to improve the speed of approximate counting. This time interestingly coincided with the removal of XORs in CryptoMiniSat. The problem was the following: A lot of new in- and preprocessing systems were being invented, mostly by Armin Biere et al, and they couldn&#39;t be added to CryptoMiniSat, because they didn&amp;#8217;t take into account XOR constraints. They handled CNF just fine, but not XORs. So XORs became a burden, and they were removed in versions 3 and 4 of CryptoMiniSat. But there was need, and this being an exciting area, the XORs had to come back.&lt;/p&gt;
&lt;h3&gt;Blast-Inprocess-Recover-Destroy&lt;/h3&gt;
&lt;p&gt;But how to both have and not have XOR constraints? Re-inventing all the algorithms for XORs was not a viable option. The solution we came up with was a rather trivial one: forget the XORs during inprocessing and recover them after. The CNF would always remain the source of truth. Extracting all the XORs after in- and preprocessing would allow us to run the Gauss-Jordan elimination on the XORs post-recovery.&lt;/p&gt;
&lt;p&gt;The process is conceptually quite easy:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Blast&lt;/strong&gt; all XORs into clauses that are in the input using intermediate variables.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perform&lt;/strong&gt; &lt;strong&gt;pre- or inprocessing&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Recover the XORs&lt;/strong&gt; from the CNF.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run the CDCL and Gauss-Jordan&lt;/strong&gt; code at the same time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Destroy the XORs&lt;/strong&gt; and goto 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This system allows for everything to be in CNF form, lifting the XORs out when necessary and then forgetting them when it&amp;#8217;s convenient. All of these steps are rather trivial, except &lt;b&gt;recovery&lt;/b&gt;, as explained below.&lt;/p&gt;
&lt;h3&gt;XOR recovery&lt;/h3&gt;
&lt;p&gt;Recovering XORs sounds like a trivial task. Let&amp;#8217;s say we have the following clauses&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;
 x1 V  x2 V  x3
-x1 V -x2 V  x3
 x1 V -x2 V -x3
-x1 V  x2 V -x3
&lt;/pre&gt;
&lt;p&gt;This is conceptually equivalent to the XOR v1+v2+v3=1. So recovering this is trivial, and has been done before, by Heule in particular, in his &lt;a href=&#34;http://www.st.ewi.tudelft.nl/sat/theses/heule_phd.pdf&#34;&gt;PhD thesis&lt;/a&gt;. The issue with the above is the following: a stronger system than the above still implies the XOR, but doesn&amp;#8217;t look the same. For example:&lt;/p&gt;
&lt;pre class=&#34;wp-block-preformatted&#34;&gt;
 x1 V  x2 V  x3
-x1 V -x2 V  x3
 x1 V -x2 V -x3
-x1 V  x2
&lt;/pre&gt;
&lt;p&gt;This is almost equivalent to the previous set of clauses, but misses a literal from one of the clauses. It still implies the XOR of course. Now what? And what to do when missing literals mean that an entire clause can be missing? The algorithm to recover XORs in such cases is non-trivial. It&amp;#8217;s non-trivial not only because of the complexity of how many combinations of missing literals and clauses there can be (it&amp;#8217;s exponential) but because one must do this work extremely fast because SAT solvers are sensitive to time.&lt;/p&gt;
&lt;p&gt;The algorithm that is in the &lt;a href=&#34;https://www.comp.nus.edu.sg/~meel/Papers/aaai19-sm.pdf&#34;&gt;paper&lt;/a&gt; explains all the bit-fiddling and cache-friendly data layout used along with some fun algorithms. We even managed to use compiler intrinsics to use target-specific assembly instructions for hamming weight calculation.&lt;/p&gt;
&lt;h3&gt;The results&lt;/h3&gt;
&lt;p&gt;The results, as shown above, speak for themselves. Problems that took thousands of seconds to solve can now be solved under 20. The reason for such incredible speedup is basically the following: CryptoMiniSatv2 was way too clunky and didn&amp;#8217;t have all the fun stuff that CryptoMiniSatv5 has, plus the XOR handling was incorrect, loosing XORs and the like. The published algorithm solves the underlying issue and allows CNF pre- and inprocessing to happen independent of XORs, thus enabling CryptoMiniSatv5 to be used in all its glory. And CryptoMiniSatv5 is &lt;em&gt;fast,&lt;/em&gt; as per the this year&amp;#8217;s SAT Competition &lt;a href=&#34;http://sat2018.forsyte.tuwien.ac.at/index.php?cat=results&#34;&gt;results&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;i&gt;We thank the &lt;a href=&#34;https://www.nscc.sg/&#34;&gt;National Supercomputing Center Singapore&lt;/a&gt;  that allowed us to run a large number of benchmarks on their machines, using at least 200 thousand CPU hours to make this paper. &lt;/i&gt;This post has been adapted from &lt;a href=&#34;https://www.msoos.org/2018/11/approxmcv3-a-modern-approximate-model-counter/&#34;&gt;Mate&#39;s post&lt;/a&gt; on ApproxMCv3.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
